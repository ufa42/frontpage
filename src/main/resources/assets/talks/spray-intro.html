
<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">

    <title>Akka &amp; spray</title>

    <meta name="description" content="Actors, IO and HTTP">
    <meta name="author" content="Mathias Doenitz">

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/reveal.js/2.6.2/css/reveal.min.css">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.0/styles/zenburn.min.css">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.1.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/reveal.js/2.6.2/css/print/pdf.css" type="text/css" media="print">
    <link rel="stylesheet" href="spray-intro.css" id="theme">

    <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script>
    <![endif]-->
</head>

<body>
<div class="reveal">
<div class="slides">

<section>
    <img style="margin-bottom: 50px;" width="80%" src="spray-logo.svg" alt="spray"><br/>
    <small><a href="http://spray.io">http://spray.io</a></small>
</section>

<section>
    <h2>Что такое spray?</h2>
    <ul>
        <li>embeddable HTTP stack for your<br/>
            Akka (Scala) applications</li>
        <li>focus: HTTP integration layers<br/>
            rather than web applications</li>
        <li>server- and client-side</li>
    </ul>
</section>

<section>
    <h2>Почему не что-то другое?</h2>
    <p class="fragment">Например <a href="http://netty.io">Java + Netty</a>?<br/>
        (или <a href="http://en.wikipedia.org/wiki/Java_Servlet">Java + Servlets</a>,
        или <a href="http://restlet.org/">Python + Django</a>,
            xtx <a href="http://undertow.io/">Ruby + Sinatra</a>, ...)</p>
</section>

<section>
    <h2>Yes, we can</h2>
    <p>(it's being done all the time)</p>
    <br/>
    <h2 class="fragment">But: Do we want to?</h2>
</section>


<section>
    <h2>Python, Django</h2>
    <pre style="width: 100%"><code data-trim style="max-height: 700px">
    def edit_title_fields(self, request, page_id, language):
        title = Title.objects.get(page_id, language)
        raw_fields = request.GET.get("edit_fields", 'title')
        edit_fields = [field for field in raw_fields.split(",")
          if field in self.title_frontend_editable_fields]
        cancel_clicked = request.POST.get("_cancel", False)
        opts = Title._meta

        if not has_permission(title.page, request.user, "change"):
            return HttpResponseForbidden(
                force_unicode(_("Permission denied")))

        if not cancel_clicked and request.method == 'POST':
            form = PageTitleForm(instance=title, data=request.POST)
            if form.is_valid():
                form.save()
                saved_successfully = True
        else:
            form = PageTitleForm(instance=title)
        if cancel_clicked:
            return render_to_response('page/confirm_form.html')
        if not cancel_clicked and request.method == 'POST':
            return render_to_response('page/confirm_form.html')
        return render_to_response('page/change_form.html')
    </code></pre>
</section>

<section>
    <h2>Not really!</h2>
    <ul class="fragment">
        <li>servlet containers?</li>
        <li>XML configuration?</li>
        <li>mutable data models / APIs?</li>
        <li>Java Collections?</li>
        <li>adapter layers?</li>
        <li>limited type-safety?</li>
    </ul>
    <aside class="notes">
        - netty: great piece of software
        - guys sure know what they are doing
        - still, its written in Java, with a Java-style API
    </aside>
</section>

<section>
    <h2>What we want</h2>
    <ul>
        <li>`case class`-based model</li>
        <li>actor-based APIs (message protocols)</li>
        <li>functions as values</li>
        <li>Scala/Akka Futures</li>
        <li>Scala collections</li>
        <li>type classes</li>
        <li>type safety</li>
    </ul>
    <aside class="notes">
        could get this by wrapping Java tools
    </aside>
</section>

<section>
    <h2>What we also want</h2>
    <ul>
        <li>unified thread-pool mgmt. (Akka dispatchers)</li>
        <li>unified configuration (<a href="https://github.com/typesafehub/config">Typesafe config</a>)</li>
        <li>unified logging (Akka event bus)</li>
        <li>unified debugging / optimization<br/>
            (e.g. with <a href="http://typesafe.com/platform/runtime/console">Typesafe console</a>)</li>
    </ul>
</section>

<section>
    <h2>We want to build on Akka!</h2>
    <ul class="fragment">
        <li>our whole application that is,<br/>
            not just a few bits!</li>
        <li>same principles, concepts and coding<br/>
            style in all layers of the stack:<br/>
            much easier problem analysis &amp; tuning</li>
    </ul>
</section>

<section>
    <h2>spray builds on Akka</h2>
    <ul>
        <li>entirely built in Scala, no wrapping of Java libraries</li>
        <li>fully async and non-blocking</li>
        <li>only one type of active components in all layers: actors</li>
        <li>core API style: message protocol</li>
        <li>actor-friendly (e.g. "tell don't ask")</li>
        <li>fast, lightweight, modular, testable</li>
    </ul>
    <aside class="notes">
        integration with akka-based application is completely seamless
    </aside>
</section>

<section>
    <h2>HTTP model</h2>
    <ul>
        <li>`case class`-based data model</li>
        <li>high-level abstractions for most things HTTP</li>
        <li>fully immutable, little logic</li>
        <li>predefined instances for common media types, status codes, encodings, charsets, cache-control directives, etc.</li>
        <li>open for extension<br/>
            (e.g. registration of custom media types)</li>
    </ul>
</section>

<section>
    <h2>HTTP model: show me code</h2>
				  <pre style="width: 75%"><code data-trim>
                      case class HttpRequest(
                      method: HttpMethod = HttpMethods.GET,
                      uri: Uri = Uri./,
                      headers: List[HttpHeader] = Nil,
                      entity: HttpEntity = HttpEntity.Empty,
                      protocol: HttpProtocol = HttpProtocols.`HTTP/1.1`
                      ) extends HttpMessage
                  </code></pre>
</section>

<section>
    <h2>HTTP model: show me code</h2>
				  <pre style="width: 75%"><code data-trim>
                      case class HttpResponse(
                      status: StatusCode = StatusCodes.OK,
                      entity: HttpEntity = HttpEntity.Empty,
                      headers: List[HttpHeader] = Nil,
                      protocol: HttpProtocol = HttpProtocols.`HTTP/1.1`
                      ) extends HttpMessage
                  </code></pre>
</section>

<section>
    <h2>HTTP model: show me code</h2>
				  <pre style="width: 70%"><code data-trim>
                      case class Uri(             // proper RFC 3986
                      scheme: String,           // compliant,
                      authority: Authority,     // immutable
                      path: Path,               // URI model
                      query: Query,             // with a fast,
                      fragment: Option[String]) // custom parser
                  </code></pre>
</section>

<section>
    <h2>HTTP model: show me code</h2>
				  <pre><code data-trim>
                      case class `Accept-Charset`(charsetRanges: Seq[HttpCharsetRange])
                      extends HttpHeader

                      case class `Accept-Encoding`(encodings: Seq[HttpEncodingRange])
                      extends HttpHeader

                      case class `Set-Cookie`(cookie: HttpCookie)
                      extends HttpHeader

                      case class RawHeader(name: String, value: String)
                      extends HttpHeader
                  </code></pre>
</section>

<section>
    <h2>Low-level HTTP layer</h2>
    <ul class="fragment">
        <li>directly sits on top of Akka IO</li>
        <li>performs TCP <i class="fa fa-resize-horizontal"></i> HTTP "translation"</li>
        <li>cleanly separated layer of actors<br/>
            provided as an Akka Extension</li>
        <li>implements "essentials",<br/>
            no higher-level features (like file serving)</li>
    </ul>
</section>

<section>
    <h2>Akka IO</h2>
    <ul>
        <li>bridges the gap between Java NIO and Akka actors</li>
        <li>msg-based API surfaces the nature of the network</li>
        <li><em>events</em> come in, e.g. &laquo;connection established&raquo;,<br/>
            &laquo;bytes received&raquo;, &raquo;connection closed&raquo;, &laquo;error occured&raquo;</li>
        <li><em>commands</em> drive from our side, e.g.<br/>
            &laquo;attempt connecting&raquo;&laquo;send bytes&raquo;,&laquo;close connection&raquo;</li>
    </ul>
    <aside class="notes">
        used to be spray-io, move to akka at the beginning of this year
    </aside>
</section>

<section>
    <h2>spray-can</h2>
    <ul>
        <li>provides message-based APIs on multiple levels<br/>
            (server-side: connection-level,<br/>
            client-side: connection-, host- and request-level)</li>
        </li>
        <li>maximum throughput with acceptable latency</li>
        <li>massive numbers of concurrent connections</li>
        <li>HTTP pipelining</li>
        <li>chunked messages (streaming)</li>
        <li>SSL/TLS encryption</li>
    </ul>
    <aside class="notes">
        - &gt; 50K on single machine, no reason why &gt; 100K shouldn't be possible
        - timeouts: request and connection idle timeout
    </aside>
</section>

<section>
    <h2>spray-can: show me code</h2>
				  <pre style="width: 90%"><code data-trim>
                      class PingPongService extends Actor {
                      def receive = {
                      // when a new connection comes in we register
                      // ourselves as the connection handler
                      case _: Http.Connected ⇒ sender ! Http.Register(self)

                      // can you guess what this does?
                      case HttpRequest(GET, Uri.Path("/"), _, _, _) ⇒
                      sender ! HttpResponse(entity = "PONG")
                      }
                      }
                  </code></pre>
    <aside class="notes">
        Easy-to-understand message protocol
    </aside>
</section>

<section>
    <h2>spray-routing</h2>
    <ul class="fragment">
        <li>internal DSL for the direct interface layer to the application</li>
        <li>type-safe, yet flexible (thanks to <a href="https://github.com/milessabin/shapeless">shapeless)</a></li>
        <li>much more than just routing: behavior definition</li>
        <li>small and simple building blocks: directives</li>
        <li>highly composable</li>
    </ul>
</section>

<section>
    <h2>API Layer Responsibilities</h2>
    <ul>
        <li>request routing based on method, path, query, entity</li>
        <li>(Un)marshalling to / from domain objects</li>
        <li>encoding / decoding (compression)</li>
        <li>authentication / authorization</li>
        <li>caching and serving static content</li>
        <li>RESTful error handling</li>
    </ul>
</section>

<section>
    <h2>API Layer: show me code</h2>
					<pre style="width: 70%"><code data-trim>
                        class MyServiceActor extends HttpServiceActor {
                        def receive = runRoute {
                        path("order" / HexIntNumber) { id =>
                        get {
                        complete {
                        "Received GET request for order " + id
                        }
                        } ~
                        put {
                        complete {
                        "Received PUT request for order " + id
                        }
                        }
                        }
                        }
                        }
                    </code></pre>
</section>

<section>
    <h2>Predefined Directives</h2>
    <p style="font-size: 60%">alwaysCache, anyParam, anyParams, authenticate, authorize, autoChunk, cache, cachingProhibited, cancelAllRejections, cancelRejection, clientIP, complete, compressResponse, compressResponseIfRequested, cookie, decodeRequest, decompressRequest, delete, deleteCookie, detach, dynamic, dynamicIf, encodeResponse, entity, extract, failWith, formField, formFields, get, getFromBrowseableDirectories, getFromBrowseableDirectory, getFromDirectory, getFromFile, getFromResource, getFromResourceDirectory, handleExceptions, handleRejections, handleWith, head, headerValue, headerValueByName, headerValuePF, hextract, host, hostName, hprovide, jsonpWithParameter, listDirectoryContents, logRequest, logRequestResponse, logResponse, mapHttpResponse, mapHttpResponseEntity, mapHttpResponseHeaders, mapHttpResponsePart, mapInnerRoute, mapRejections, mapRequest, mapRequestContext, mapRouteResponse, mapRouteResponsePF, method, noop, onComplete, onFailure, onSuccess, optionalCookie, optionalHeaderValue, optionalHeaderValueByName, optionalHeaderValuePF, options, overrideMethodWithParameter, parameter, parameterMap, parameterMultiMap, parameters, parameterSeq, pass, patch, path, pathPrefix, pathPrefixTest, pathSuffix, pathSuffixTest, post, produce, provide, put, rawPath, rawPathPrefix, rawPathPrefixTest, redirect, reject, rejectEmptyResponse, requestEncodedWith, requestEntityEmpty, requestEntityPresent, respondWithHeader, respondWithHeaders, respondWithLastModifiedHeader, respondWithMediaType, respondWithSingletonHeader, respondWithSingletonHeaders, respondWithStatus, responseEncodingAccepted, rewriteUnmatchedPath, routeRouteResponse, scheme, schemeName, setCookie, unmatchedPath, validate</p>
</section>

<section>
    <h2>Real-World Example</h2>
					<pre style="font-size: 40%"><code data-trim>
                        lazy val route = {
                        encodeResponse(Gzip) {
                        path("") {
                        get {
                        redirect("/doc")
                        }
                        } ~
                        pathPrefix("api") {
                        jsonpWithParameter("callback") {
                        path("top-articles") {
                        get {
                        parameter("max".as[Int]) { max =>
                        validate(max >= 0, "query parameter 'max' must be >= 0") {
                        complete {
                        (topArticlesService ? max).mapTo[Seq[Article]]
                        }
                        }
                        }
                        }
                        } ~
                        tokenAuthenticate { user =>
                        path("ranking") {
                        get {
                        countAndTime(user, "ranking") {
                        parameters("fixed" ? 0, "mobile" ? 0, "sms" ? 0, "mms" ? 0,
                        "data" ? 0).as(RankingDescriptor) { descr =>
                        complete {
                        (rankingService ? Ranking(descr)).mapTo[RankingResult]
                        }
                        }
                        }
                        }
                        } ~
                        path("accounts") {
                        post {
                        authorize(user.isAdmin) {
                        content(as[AccountDetails]) { details =>
                        complete {
                        (accountService ? NewAccount(details)).mapTo[OpResult]
                        }
                        }
                        }
                        }
                        } ~
                        path("account" / IntNumber) { accountId =>
                        get { ... } ~
                        put { ... } ~
                        delete { ... }
                        }
                        }
                        } ~
                        pathPrefix("v1") {
                        proxyToDjango
                        }
                        } ~
                        pathPrefix("doc") {
                        respondWithHeader(`Cache-Control`(`max-age`(3600))) {
                        transformResponse(_.withContentTransformed(markdown2Html)) {
                        getFromResourceDirectory("doc/root",
                        pathRewriter = appendFileExt)
                        }
                        }
                        } ~
                        } ~
                        cacheIfEnabled {
                        encodeResponse(Gzip) {
                        getFromResourceDirectory("public")
                        }
                        }
                        }
                    </code></pre>
</section>

<section>
    <h2>Best Practices</h2>
    <ul>
        <li>Keep route structure clean and readable, <br/>
            pull out all logic into custom directives</li>
        <li>Don’t let API layer leak into application</li>
        <li>Use (Un)marshalling infrastructure</li>
        <li>Think about error handling/reporting<br/>right from the start</li>
        <li>Use <a href="https://github.com/spray/sbt-revolver‎">sbt-revolver</a> for fast dev turn-around</li>
    </ul>
</section>

<section>
    <h2>There is more...</h2>
    <ul>
        <li><a href="http://spray.io/documentation/1.2-RC2/spray-servlet/">spray-servlet</a></li>
        <li>Request/response streaming</li>
        <li><a href="http://spray.io/documentation/1.2-RC2/spray-testkit/">Testing routes</a></li>
        <li>client-side APIs</li>
        <li>JSON support</li>
        <li>...</li>
    </ul>
</section>

<section>
    <h2>Current State</h2>
    <ul>
        <li>Latest release: spray 1.[0123].1</li>
        <li>Currently: <a href="http://typesafe.com/blog/typesafe-gets-sprayed"><em>spray</em> becomes <em>akka-http</em></a></li>
        <li><a href="http://www.playframework.com">Play</a> will gradually move onto <em>akka-http</em></li>
        <li>Then: Improvements, features, rounding off
            <ul>
                <li>websockets</li>
                <li>HTTP 2.0</li>
                <li>...</li>
            </ul>
    </ul>
</section>

<section>
    <h2>akka-http</h2>
    <ul>
        <li>Only two modules (down from 10)
            <ul>
                <li>akka-http-core</li>
                <li>akka-http</li>
            </ul>
        </li>
        <li>No more spray-servlet (at least for now)</li>
        <li>Java APIs</li>
        <li>Main improvement:<br>Everything now based on <a href="http://www.reactive-streams.org/">Reactive Streams</a></li>
    </ul>
</section>

<section>
    <h2>Getting started</h2>
    <ul>
        <li>Main sites &amp; documentation:<br/>
            <a href="http://akka.io">http://akka.io</a><br/>
            <a href="http://spray.io">http://spray.io</a><br/>
            <a href="http://www.reactive-streams.org/">http://www.reactive-streams.org/</a>
        </li>
        <li>Mailing lists:<br/>
            <a href="http://groups.google.com/group/akka-user"> http://groups.google.com/group/akka-user</a><br/>
            <a href="http://groups.google.com/group/spray-user"> http://groups.google.com/group/spray-user</a>
        </li>
        <li>Twitter: <br/>
            <a href="https://twitter.com/akkateam">@akkateam</a>, <a href="https://twitter.com/sprayio">@sprayio</a></li>
    </ul>
</section>

<section>
    <h2>THANK YOU!</h2>
</section>

<section>
    <h2>Q &amp; A</h2>
</section>
</div>
</div>

<script src="//cdnjs.cloudflare.com/ajax/libs/reveal.js/2.6.2/lib/js/head.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/reveal.js/2.6.2/js/reveal.min.js"></script>

<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				theme: Reveal.getQueryHash().theme || 'spray-intro', // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'fade', // default/cube/page/concave/zoom/linear/fade/none

				transitionSpeed: 'fast',

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: '//cdnjs.cloudflare.com/ajax/libs/classlist/2014.01.31/classList.min.js', condition: function() { return !document.body.classList; } },
					{ src: '//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.0/highlight.min.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});

		</script>

</body>
</html>
